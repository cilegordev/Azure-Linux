# Changes adopted from python3-rpm-generators-10-4.fc32.noarch.rpm

diff --git a/scripts/pythondistdeps.py b/scripts/pythondistdeps.py
index ac1cd62..8756fdf 100755
--- a/scripts/pythondistdeps.py
+++ b/scripts/pythondistdeps.py
@@ -1,4 +1,4 @@
-#!/usr/bin/python
+#!/usr/bin/python3
 # -*- coding: utf-8 -*-
 #
 # Copyright 2010 Per Ã˜yvind Karlsen <proyvind@moondrake.org>
@@ -32,6 +32,11 @@ PyMajorVer_Deps = False
 legacy_Provides = False
 legacy = False
 
+def normalize_name(name):
+    """https://www.python.org/dev/peps/pep-0503/#normalized-names"""
+    import re
+    return re.sub(r'[-_.]+', '-', name).lower()
+
 for o, a in opts:
     if o in ('-h', '--help'):
         print('-h, --help\tPrint help')
@@ -102,7 +107,7 @@ for f in files:
             lower.endswith('.egg-info') or \
             lower.endswith('.dist-info'):
         # This import is very slow, so only do it if needed
-        from pkg_resources import Distribution, FileMetadata, PathMetadata
+        from pkg_resources import Distribution, FileMetadata, PathMetadata, Requirement, parse_version
         dist_name = basename(f)
         if isdir(f):
             path_item = dirname(f)
@@ -116,12 +121,24 @@ for f in files:
             # Try to parse the Python version from the path the metadata
             # resides at (e.g. /usr/lib/pythonX.Y/site-packages/...)
             import re
-            res = re.search(r"/python(?P<pyver>\d+\.\d)/", path_item)
+            res = re.search(r"/python(?P<pyver>\d+\.\d+)/", path_item)
             if res:
                 dist.py_version = res.group('pyver')
             else:
                 warn("Version for {!r} has not been found".format(dist), RuntimeWarning)
                 continue
+
+        # XXX: https://github.com/pypa/setuptools/pull/1275
+        import platform
+        platform.python_version = lambda: dist.py_version
+
+        # This is the PEP 503 normalized name.
+        # It does also convert dots to dashes, unlike dist.key.
+        # In the current code, we only add additional provides with this.
+        # Later, we can start requiring them.
+        # See https://bugzilla.redhat.com/show_bug.cgi?id=1791530
+        normalized_name = normalize_name(dist.project_name)
+
         if Provides_PyMajorVer_Variant or PyMajorVer_Deps or legacy_Provides or legacy:
             # Get the Python major version
             pyver_major = dist.py_version.split('.')[0]
@@ -136,21 +153,34 @@ for f in files:
                 name = 'python{}dist({})'.format(dist.py_version, dist.key)
                 if name not in py_deps:
                     py_deps[name] = []
+                name_ = 'python{}dist({})'.format(dist.py_version, normalized_name)
+                if name_ not in py_deps:
+                    py_deps[name_] = []
             if Provides_PyMajorVer_Variant or PyMajorVer_Deps:
                 pymajor_name = 'python{}dist({})'.format(pyver_major, dist.key)
                 if pymajor_name not in py_deps:
                     py_deps[pymajor_name] = []
+                pymajor_name_ = 'python{}dist({})'.format(pyver_major, normalized_name)
+                if pymajor_name_ not in py_deps:
+                    py_deps[pymajor_name_] = []
             if legacy or legacy_Provides:
                 legacy_name = 'pythonegg({})({})'.format(pyver_major, dist.key)
                 if legacy_name not in py_deps:
                     py_deps[legacy_name] = []
             if dist.version:
-                spec = ('==', dist.version)
+                version = dist.version
+                while version.endswith('.0'):
+                    version = version[:-2]
+                spec = ('==', version)
                 if spec not in py_deps[name]:
                     if not legacy:
                         py_deps[name].append(spec)
+                        if name != name_:
+                            py_deps[name_].append(spec)
                     if Provides_PyMajorVer_Variant:
                         py_deps[pymajor_name].append(spec)
+                        if pymajor_name != pymajor_name_:
+                            py_deps[pymajor_name_].append(spec)
                     if legacy or legacy_Provides:
                         py_deps[legacy_name].append(spec)
         if Requires or (Recommends and dist.extras):
@@ -174,6 +204,13 @@ for f in files:
                         if dep in deps:
                             depsextras.remove(dep)
                 deps = depsextras
+            # console_scripts/gui_scripts entry points need pkg_resources from setuptools
+            if ((dist.get_entry_map('console_scripts') or
+                     dist.get_entry_map('gui_scripts')) and
+                    (lower.endswith('.egg') or
+                     lower.endswith('.egg-info'))):
+                # stick them first so any more specific requirement overrides it
+                deps.insert(0, Requirement.parse('setuptools'))
             # add requires/recommends based on egg/dist metadata
             for dep in deps:
                 if legacy:
@@ -184,11 +221,12 @@ for f in files:
                     else:
                         name = 'python{}dist({})'.format(dist.py_version, dep.key)
                 for spec in dep.specs:
-                    if spec[0] != '!=':
-                        if name not in py_deps:
-                            py_deps[name] = []
-                        if spec not in py_deps[name]:
-                            py_deps[name].append(spec)
+                    while spec[1].endswith('.0'):
+                        spec = (spec[0], spec[1][:-2])
+                    if name not in py_deps:
+                        py_deps[name] = []
+                    if spec not in py_deps[name]:
+                        py_deps[name].append(spec)
                 if not dep.specs:
                     py_deps[name] = []
         # Unused, for automatic sub-package generation based on 'extras' from egg/dist metadata
@@ -233,8 +271,35 @@ names.sort()
 for name in names:
     if py_deps[name]:
         # Print out versioned provides, requires, recommends, conflicts
+        spec_list = []
         for spec in py_deps[name]:
-            print('{} {} {}'.format(name, spec[0], spec[1]))
+            if spec[0] == '!=':
+                spec_list.append('({n} < {v} or {n} >= {v}.0)'.format(n=name, v=spec[1]))
+            elif spec[0] == '~=':
+                # Parse the current version
+                next_ver = parse_version(spec[1]).base_version.split('.')
+                # Drop the micro version
+                next_ver = next_ver[0:-1]
+                # Increment the minor version
+                next_ver[-1] = str(int(next_ver[-1]) + 1)
+                next_ver = '.'.join(next_ver)
+                spec_list.append('({n} >= {v} with {n} < {vnext})'.format(n=name, v=spec[1], vnext=next_ver))
+            elif spec[0] == '==' and spec[1].endswith('.*'):
+                # Parse the current version
+                next_ver = parse_version(spec[1]).base_version.split('.')
+                # Drop the micro version from both the version in spec and next_ver
+                next_ver = next_ver[0:-1]
+                spec = (spec[0], '.'.join(next_ver))
+                # Increment the minor version
+                next_ver[-1] = str(int(next_ver[-1]) + 1)
+                next_ver = '.'.join(next_ver)
+                spec_list.append('({n} >= {v} with {n} < {vnext})'.format(n=name, v=spec[1], vnext=next_ver))
+            else:
+                spec_list.append('{} {} {}'.format(name, spec[0], spec[1]))
+        if len(spec_list) == 1:
+            print(spec_list[0])
+        else:
+            print('({})'.format(' with '.join(spec_list)))
     else:
         # Print out unversioned provides, requires, recommends, conflicts
         print(name)
