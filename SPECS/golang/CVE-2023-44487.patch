From 9090209645b6984947ebc7ed8dad1ff6851351f3 Mon Sep 17 00:00:00 2001
From: Davis Goodin <dagood@microsoft.com>
Date: Fri, 6 Oct 2023 10:00:13 -0700
Subject: [PATCH] net/http: add configurable http2 limits and reduce
 unnecessary work

---
 src/net/http/h2_bundle.go | 393 +++++++++++++++++++++++++++++++++++---
 1 file changed, 370 insertions(+), 23 deletions(-)

diff --git a/src/net/http/h2_bundle.go b/src/net/http/h2_bundle.go
index 1e0b83d493..4a8119161f 100644
--- a/src/net/http/h2_bundle.go
+++ b/src/net/http/h2_bundle.go
@@ -3791,11 +3791,178 @@ func (p *http2pipe) Done() <-chan struct{} {
 }
 
 const (
-	http2prefaceTimeout         = 10 * time.Second
-	http2firstSettingsTimeout   = 2 * time.Second // should be in-flight with preface anyway
-	http2handlerChunkWriteSize  = 4 << 10
-	http2defaultMaxStreams      = 250 // TODO: make this 100 as the GFE seems to?
-	http2maxQueuedControlFrames = 10000
+	http2prefaceTimeout        = 10 * time.Second
+	http2firstSettingsTimeout  = 2 * time.Second // should be in-flight with preface anyway
+	http2handlerChunkWriteSize = 4 << 10
+	http2defaultMaxStreams     = 250 // TODO: make this 100 as the GFE seems to?
+)
+
+// Set up limits configured by environment variables.
+func init() {
+	var fail bool
+	checkErr := func(name string, err error) {
+		if err != nil {
+			fmt.Fprintf(os.Stderr, "could not parse environment for http2 limit config: %v: %v\n", name, err)
+			fail = true
+		}
+	}
+	boolEnv := func(name string) (bool, bool) {
+		if v := os.Getenv(name); v != "" {
+			b, err := strconv.ParseBool(v)
+			checkErr(name, err)
+			return b, true
+		}
+		return false, false
+	}
+	setBoolEnv := func(name string, p *bool) {
+		if v, ok := boolEnv(name); ok {
+			*p = v
+		}
+	}
+	setUint32Env := func(name string, p *uint32) {
+		if v := os.Getenv(name); v != "" {
+			parsed, err := strconv.ParseUint(v, 10, 32)
+			checkErr(name, err)
+			*p = uint32(parsed)
+		}
+	}
+	setInt32Env := func(name string, p *int) {
+		if v := os.Getenv(name); v != "" {
+			parsed, err := strconv.ParseInt(v, 10, 32)
+			checkErr(name, err)
+			*p = int(parsed)
+		}
+	}
+	setFloat64Env := func(name string, p *float64) {
+		if v := os.Getenv(name); v != "" {
+			parsed, err := strconv.ParseFloat(v, 64)
+			checkErr(name, err)
+			*p = parsed
+		}
+
+	}
+	setDurationEnv := func(name string, p *time.Duration) {
+		if v := os.Getenv(name); v != "" {
+			parsed, err := time.ParseDuration(v)
+			checkErr(name, err)
+			*p = parsed
+		}
+	}
+
+	const (
+		rrlEnable        = "MS_GO_HTTP2_RESET_RATE_LIMIT_ENABLE"
+		rrlMax           = "MS_GO_HTTP2_RESET_RATE_LIMIT_MAX"
+		rrlWindow        = "MS_GO_HTTP2_RESET_RATE_LIMIT_WINDOW"
+		rpEnable         = "MS_GO_HTTP2_MAX_RESET_PROPORTION_ENABLE"
+		rpPercent        = "MS_GO_HTTP2_MAX_RESET_PROPORTION_PERCENT"
+		rpMinReq         = "MS_GO_HTTP2_MAX_RESET_PROPORTION_MIN_REQUESTS"
+		eycGoAwayTimeout = "MS_GO_HTTP2_CUSTOM_EYC_GOAWAY_TIMEOUT"
+		prEnable         = "MS_GO_HTTP2_PREMATURE_RESET_LIMIT_ENABLE"
+		prMinStreams     = "MS_GO_HTTP2_PREMATURE_RESET_LIMIT_MIN_STREAMS"
+		chlEnable        = "MS_GO_HTTP2_CONCURRENT_HANDLER_LIMIT_ENABLE"
+		chlDouble        = "MS_GO_HTTP2_CONCURRENT_HANDLER_LIMIT_DOUBLE"
+		chhlEnable       = "MS_GO_HTTP2_CONCURRENT_HEADER_HANDLER_LIMIT_ENABLE"
+		closeConn        = "MS_GO_HTTP2_EAGER_CLOSE_CONNECTION"
+		qcfMax           = "MS_GO_HTTP2_MAX_QUEUED_CONTROL_FRAMES"
+		reuseF           = "MS_GO_HTTP2_REUSE_FRAMES"
+		configEcho       = "MS_GO_HTTP2_CONFIG_ECHO"
+	)
+
+	setBoolEnv(rrlEnable, &http2enableResetRateLimit)
+	if http2enableResetRateLimit {
+		setUint32Env(rrlMax, &http2resetRateLimitMax)
+		setDurationEnv(rrlWindow, &http2resetRateLimitWindow)
+	}
+
+	setBoolEnv(rpEnable, &http2enableProportionalMaxReset)
+	if http2enableProportionalMaxReset {
+		setFloat64Env(rpPercent, &http2proportionalMaxResetPercent)
+		setUint32Env(rpMinReq, &http2proportionalMinRequests)
+	}
+
+	setDurationEnv(eycGoAwayTimeout, &http2goAwayEnhanceYourCalmTimeout)
+
+	setBoolEnv(prEnable, &http2enablePrematureResetLimit)
+	if http2enablePrematureResetLimit {
+		setUint32Env(prMinStreams, &http2prematureResetLimitMinStreams)
+	}
+
+	setBoolEnv(chlEnable, &http2enableConcurrentHandlerLimit)
+	if http2enableConcurrentHandlerLimit {
+		if enabled, _ := boolEnv(chlDouble); enabled {
+			http2concurrentHandlerFactor = 2
+		}
+	}
+
+	setBoolEnv(chhlEnable, &http2enableConcurrentHeaderHandlerLimit)
+
+	setBoolEnv(closeConn, &http2eagerCloseConnection)
+
+	setInt32Env(qcfMax, &http2maxQueuedControlFrames)
+
+	setBoolEnv(reuseF, &http2reuseFrames)
+
+	setBoolEnv(configEcho, &http2enableConfigEcho)
+
+	if http2enableConfigEcho {
+		fmt.Fprintln(os.Stderr, "--- http2 rate limit extras --- list of effective settings ---")
+		fmt.Fprintln(os.Stderr, rrlEnable, "=", http2enableResetRateLimit)
+		fmt.Fprintln(os.Stderr, rrlMax, "=", http2resetRateLimitMax)
+		fmt.Fprintln(os.Stderr, rrlWindow, "=", http2resetRateLimitWindow)
+		fmt.Fprintln(os.Stderr, rpEnable, "=", http2enableProportionalMaxReset)
+		fmt.Fprintln(os.Stderr, rpPercent, "=", http2proportionalMaxResetPercent)
+		fmt.Fprintln(os.Stderr, rpMinReq, "=", http2proportionalMinRequests)
+		fmt.Fprintln(os.Stderr, eycGoAwayTimeout, "=", http2goAwayEnhanceYourCalmTimeout)
+		fmt.Fprintln(os.Stderr, prEnable, "=", http2enablePrematureResetLimit)
+		fmt.Fprintln(os.Stderr, prMinStreams, "=", http2prematureResetLimitMinStreams)
+		fmt.Fprintln(os.Stderr, chlEnable, "=", http2enableConcurrentHandlerLimit)
+		fmt.Fprintln(os.Stderr, chlDouble, "resulted in factor of", http2concurrentHandlerFactor)
+		fmt.Fprintln(os.Stderr, chhlEnable, "=", http2enableConcurrentHeaderHandlerLimit)
+		fmt.Fprintln(os.Stderr, closeConn, "=", http2eagerCloseConnection)
+		fmt.Fprintln(os.Stderr, qcfMax, "=", http2maxQueuedControlFrames)
+		fmt.Fprintln(os.Stderr, reuseF, "=", http2reuseFrames)
+		fmt.Fprintln(os.Stderr, configEcho, "=", http2enableConfigEcho)
+	}
+
+	if fail {
+		os.Exit(1)
+	}
+}
+
+// Controls for additional rate limiting and performance-related configuration.
+// The defaults below are based on other implementations and experimentation and
+// aren't tuned to a specific Go scenario unless noted.
+var (
+	http2enableResetRateLimit bool                      // enable a rate limit on the number of resets performed by a connection.
+	http2resetRateLimitMax    uint32 = 1000             // Maximum number of resets to allow.
+	http2resetRateLimitWindow        = time.Second * 30 // The time window the maximum limit is applied to. Performs a simple counter reset. Not a sliding window.
+
+	http2enableProportionalMaxReset  bool           // Enable a maximum number of resets as a percentage of new streams created.
+	http2proportionalMaxResetPercent float64 = 99.0 // Maximum % of resets per new streams to allow.
+	http2proportionalMinRequests     uint32  = 1000 // Minimum number of requests before applying the max reset rate.
+
+	http2goAwayEnhanceYourCalmTimeout = http2goAwayTimeout // An override timeout for a GOAWAY with the EnhanceYourCalm error.
+
+	// Enable a limit to the number of times a connection can prematurely reset
+	// streams. A reset is considered premature if it arrives before the
+	// response headers are sent.
+	http2enablePrematureResetLimit     bool
+	http2prematureResetLimitMinStreams uint32 = 500 // Number of total streams that must be reached before the rule is applied.
+
+	// Enable a limit to the number of handlers that will run concurrently to
+	// serve each connection. The limit is set to the max number of streams.
+	http2enableConcurrentHandlerLimit bool   = true
+	http2concurrentHandlerFactor      uint32 = 1 // A multiple of the max number of streams to use as the limit. 1, or 2 if doubled by config.
+
+	// Enable a limit to the number of headers that will be handled concurrently.
+	// This uses the same limit as the concurrent handler limit.
+	http2enableConcurrentHeaderHandlerLimit bool = true
+
+	http2eagerCloseConnection   bool        // Treat some stream errors as connection errors to eagerly close the connection.
+	http2maxQueuedControlFrames int  = 500  // Maximum number of control frames that can be queued. Exceeding this limit closes the connection.
+	http2reuseFrames            bool = true // Call SetReuseFrames. It isn't clear this is safe, but we haven't found a reason not to.
+
+	http2enableConfigEcho bool // Print the settings to stderr. Use to ensure the config is as expected.
 )
 
 var (
@@ -4165,6 +4332,13 @@ func (s *http2Server) ServeConn(c net.Conn, opts *http2ServeConnOpts) {
 		sawClientPreface:            opts.SawClientPreface,
 	}
 
+	if http2enableConcurrentHeaderHandlerLimit {
+		sc.headerHandlerSem = make(chan struct{}, s.maxConcurrentStreams()*http2concurrentHandlerFactor)
+		for i := 0; i < cap(sc.headerHandlerSem); i++ {
+			sc.headerHandlerSem <- struct{}{}
+		}
+	}
+
 	s.state.registerConn(sc)
 	defer s.state.unregisterConn(sc)
 
@@ -4198,6 +4372,9 @@ func (s *http2Server) ServeConn(c net.Conn, opts *http2ServeConnOpts) {
 	fr.ReadMetaHeaders = hpack.NewDecoder(s.maxDecoderHeaderTableSize(), nil)
 	fr.MaxHeaderListSize = sc.maxHeaderListSize()
 	fr.SetMaxReadFrameSize(s.maxReadFrameSize())
+	if http2reuseFrames {
+		fr.SetReuseFrames()
+	}
 	sc.framer = fr
 
 	if tc, ok := c.(http2connectionStater); ok {
@@ -4308,6 +4485,8 @@ type http2serverConn struct {
 	remoteAddrStr    string
 	writeSched       http2WriteScheduler
 
+	headerHandlerSem chan struct{} // semaphore restricting the number of active header handlers. Receive to lock, send to unlock.
+
 	// Everything following is owned by the serve loop; use serveG.check():
 	serveG                      http2goroutineLock // used to verify funcs are on serve()
 	pushEnabled                 bool
@@ -4320,9 +4499,11 @@ type http2serverConn struct {
 	advMaxStreams               uint32 // our SETTINGS_MAX_CONCURRENT_STREAMS advertised the client
 	curClientStreams            uint32 // number of open streams initiated by the client
 	curPushedStreams            uint32 // number of open streams initiated by server push
+	curHandlers                 uint32 // number of running handler goroutines
 	maxClientStreamID           uint32 // max ever seen from client (odd), or 0 if there have been no client requests
 	maxPushPromiseID            uint32 // ID of the last push promise (even), or 0 if there have been no pushes
 	streams                     map[uint32]*http2stream
+	unstartedHandlers           []http2unstartedHandler
 	initialStreamSendWindowSize int32
 	maxFrameSize                int32
 	peerMaxHeaderListSize       uint32            // zero means unknown (default)
@@ -4338,6 +4519,21 @@ type http2serverConn struct {
 	shutdownTimer               *time.Timer // nil until used
 	idleTimer                   *time.Timer // nil if unused
 
+	// Also owned by the serve loop; use serveG.check():
+
+	// totalStreams is used by enablePrematureResetLimit and enableProportionalMaxReset.
+	// Total number of streams created over lifetime of the connection.
+	totalStreams uint32
+
+	// See enableResetRateLimit bool
+	resetCount     uint32
+	nextCountReset time.Time
+	// See enableProportionalMaxReset bool
+	totalResetRequests uint32
+
+	minResetStreams       uint32 // number of streams which must be reset before checking for excessive prematurely reset streams.
+	prematureResetStreams uint32 // number of premature reset streams
+
 	// Owned by the writeFrameAsync goroutine:
 	headerWriteBuf bytes.Buffer
 	hpackEncoder   *hpack.Encoder
@@ -4718,6 +4914,8 @@ func (sc *http2serverConn) serve() {
 					return
 				case http2gracefulShutdownMsg:
 					sc.startGracefulShutdownInternal()
+				case http2handlerDoneMsg:
+					sc.handlerDone()
 				default:
 					panic("unknown timer")
 				}
@@ -4744,7 +4942,11 @@ func (sc *http2serverConn) serve() {
 		sentGoAway := sc.inGoAway && !sc.needToSendGoAway && !sc.writingFrame
 		gracefulShutdownComplete := sc.goAwayCode == http2ErrCodeNo && sc.curOpenStreams() == 0
 		if sentGoAway && sc.shutdownTimer == nil && (sc.goAwayCode != http2ErrCodeNo || gracefulShutdownComplete) {
-			sc.shutDownIn(http2goAwayTimeout)
+			if sc.goAwayCode == http2ErrCodeEnhanceYourCalm {
+				sc.shutDownIn(http2goAwayEnhanceYourCalmTimeout)
+			} else {
+				sc.shutDownIn(http2goAwayTimeout)
+			}
 		}
 	}
 }
@@ -4765,6 +4967,7 @@ var (
 	http2idleTimerMsg        = new(http2serverMessage)
 	http2shutdownTimerMsg    = new(http2serverMessage)
 	http2gracefulShutdownMsg = new(http2serverMessage)
+	http2handlerDoneMsg      = new(http2serverMessage)
 )
 
 func (sc *http2serverConn) onSettingsTimer() { sc.sendServeMsg(http2settingsTimerMsg) }
@@ -5171,6 +5374,7 @@ func (sc *http2serverConn) resetStream(se http2StreamError) {
 	sc.writeFrame(http2FrameWriteRequest{write: se})
 	if st, ok := sc.streams[se.StreamID]; ok {
 		st.resetQueued = true
+		st.cancelCtx()
 	}
 }
 
@@ -5336,6 +5540,20 @@ func (sc *http2serverConn) processWindowUpdate(f *http2WindowUpdateFrame) error
 func (sc *http2serverConn) processResetStream(f *http2RSTStreamFrame) error {
 	sc.serveG.check()
 
+	if http2enableResetRateLimit {
+		now := time.Now()
+		if now.After(sc.nextCountReset) {
+			sc.nextCountReset = now.Add(http2resetRateLimitWindow)
+			sc.resetCount = 0
+		}
+		// Count all reset frames, whether or not there is an associated active stream. This rate
+		// limit is following an approach that simply counts incoming frames.
+		sc.resetCount++
+		if sc.resetCount > http2resetRateLimitMax {
+			return sc.countError("", http2ConnectionError(http2ErrCodeEnhanceYourCalm))
+		}
+	}
+
 	state, st := sc.state(f.StreamID)
 	if state == http2stateIdle {
 		// 6.4 "RST_STREAM frames MUST NOT be sent for a
@@ -5346,8 +5564,30 @@ func (sc *http2serverConn) processResetStream(f *http2RSTStreamFrame) error {
 		return sc.countError("reset_idle_stream", http2ConnectionError(http2ErrCodeProtocol))
 	}
 	if st != nil {
+		if http2enableProportionalMaxReset {
+			// Count reset requests that are actually closing a stream. This counter is compared to
+			// a counter tracking number of streams that are actually created. Counting only
+			// actually-closed streams is intended to keep the counts balanced.
+			sc.totalResetRequests++
+			rate := 100 * float64(sc.totalResetRequests) / float64(sc.totalStreams)
+			if sc.totalStreams > uint32(http2proportionalMinRequests) && rate > http2proportionalMaxResetPercent {
+				return sc.countError("", http2ConnectionError(http2ErrCodeEnhanceYourCalm))
+			}
+		}
 		st.cancelCtx()
 		sc.closeStream(st, http2streamError(f.StreamID, f.ErrCode))
+		if http2enablePrematureResetLimit {
+			// Check if the request was prematurely reset, by comparing its lifetime
+			// to the configured threshold.
+			if !st.wroteHeaders {
+				sc.prematureResetStreams++
+				if sc.totalStreams > http2prematureResetLimitMinStreams &&
+					float64(sc.prematureResetStreams)/float64(sc.totalStreams) >= 0.5 {
+					// Returning an error here will cause a GOAWAY to be sent.
+					return sc.countError("too_many_premature_resets", http2ConnectionError(http2ErrCodeEnhanceYourCalm))
+				}
+			}
+		}
 	}
 	return nil
 }
@@ -5369,6 +5609,7 @@ func (sc *http2serverConn) closeStream(st *http2stream, err error) {
 	} else {
 		sc.curClientStreams--
 	}
+	st.cancelCtx()
 	delete(sc.streams, st.id)
 	if len(sc.streams) == 0 {
 		sc.setConnState(StateIdle)
@@ -5533,7 +5774,11 @@ func (sc *http2serverConn) processData(f *http2DataFrame) error {
 			// Already have a stream error in flight. Don't send another.
 			return nil
 		}
-		return sc.countError("closed", http2streamError(id, http2ErrCodeStreamClosed))
+		if http2eagerCloseConnection {
+			return sc.countError("closed", http2ConnectionError(http2ErrCodeStreamClosed))
+		} else {
+			return sc.countError("closed", http2streamError(id, http2ErrCodeStreamClosed))
+		}
 	}
 	if st.body == nil {
 		panic("internal error: should have a body in this state")
@@ -5675,7 +5920,11 @@ func (sc *http2serverConn) processHeaders(f *http2MetaHeadersFrame) error {
 		// this state, it MUST respond with a stream error (Section 5.4.2) of
 		// type STREAM_CLOSED.
 		if st.state == http2stateHalfClosedRemote {
-			return sc.countError("headers_half_closed", http2streamError(id, http2ErrCodeStreamClosed))
+			if http2eagerCloseConnection {
+				return sc.countError("headers_half_closed", http2ConnectionError(http2ErrCodeStreamClosed))
+			} else {
+				return sc.countError("headers_half_closed", http2streamError(id, http2ErrCodeStreamClosed))
+			}
 		}
 		return st.processTrailerHeaders(f)
 	}
@@ -5713,6 +5962,24 @@ func (sc *http2serverConn) processHeaders(f *http2MetaHeadersFrame) error {
 		return sc.countError("over_max_streams_race", http2streamError(id, http2ErrCodeRefusedStream))
 	}
 
+	var scheduled bool
+	if http2enableConcurrentHeaderHandlerLimit {
+		t := time.NewTimer(33 * time.Second) // longer than the 30-second timeout used by kube clients
+		defer t.Stop()
+
+		select {
+		case <-sc.headerHandlerSem:
+		case <-t.C:
+			return sc.countError("timeout_handlers", http2streamError(id, http2ErrCodeEnhanceYourCalm))
+		}
+
+		defer func() {
+			if !scheduled {
+				sc.headerHandlerSem <- struct{}{}
+			}
+		}()
+	}
+
 	initialState := http2stateOpen
 	if f.StreamEnded() {
 		initialState = http2stateHalfClosedRemote
@@ -5759,7 +6026,8 @@ func (sc *http2serverConn) processHeaders(f *http2MetaHeadersFrame) error {
 		}
 	}
 
-	go sc.runHandler(rw, req, handler)
+	scheduled = true
+	sc.scheduleHandler(id, rw, req, handler, true)
 	return nil
 }
 
@@ -5780,7 +6048,7 @@ func (sc *http2serverConn) upgradeRequest(req *Request) {
 		sc.conn.SetReadDeadline(time.Time{})
 	}
 
-	go sc.runHandler(rw, req, sc.handler.ServeHTTP)
+	sc.scheduleHandler(id, rw, req, sc.handler.ServeHTTP, false)
 }
 
 func (st *http2stream) processTrailerHeaders(f *http2MetaHeadersFrame) error {
@@ -5838,6 +6106,14 @@ func (sc *http2serverConn) newStream(id, pusherID uint32, state http2streamState
 		panic("internal error: cannot create stream with id 0")
 	}
 
+	sc.totalStreams++
+	// Detect wraparounds.
+	if sc.totalStreams == 0 {
+		// Reset the premature reset counter, else
+		// it will skew the reset ratio.
+		sc.prematureResetStreams = 0
+	}
+
 	ctx, cancelCtx := context.WithCancel(sc.baseCtx)
 	st := &http2stream{
 		sc:        sc,
@@ -6010,25 +6286,88 @@ func (sc *http2serverConn) newWriterAndRequestNoBody(st *http2stream, rp http2re
 }
 
 func (sc *http2serverConn) newResponseWriter(st *http2stream, req *Request) *http2responseWriter {
-	rws := http2responseWriterStatePool.Get().(*http2responseWriterState)
-	bwSave := rws.bw
-	*rws = http2responseWriterState{} // zero all the fields
-	rws.conn = sc
-	rws.bw = bwSave
-	rws.bw.Reset(http2chunkWriter{rws})
-	rws.stream = st
-	rws.req = req
-	return &http2responseWriter{rws: rws}
+	out := &http2responseWriter{}
+	out.prep = func() {
+		rws := http2responseWriterStatePool.Get().(*http2responseWriterState)
+		bwSave := rws.bw
+		*rws = http2responseWriterState{} // zero all the fields
+		rws.conn = sc
+		rws.bw = bwSave
+		rws.bw.Reset(http2chunkWriter{rws})
+		rws.stream = st
+		rws.req = req
+		out.rws = rws
+	}
+	return out
+}
+
+type http2unstartedHandler struct {
+	streamID uint32
+	rw       *http2responseWriter
+	req      *Request
+	handler  func(ResponseWriter, *Request)
+	isHeader bool
+}
+
+// scheduleHandler starts a handler goroutine,
+// or schedules one to start as soon as an existing handler finishes.
+func (sc *http2serverConn) scheduleHandler(streamID uint32, rw *http2responseWriter, req *Request, handler func(ResponseWriter, *Request), isHeader bool) {
+	sc.serveG.check()
+	maxHandlers := sc.advMaxStreams * http2concurrentHandlerFactor
+	if sc.curHandlers < maxHandlers || !http2enableConcurrentHandlerLimit {
+		sc.curHandlers++
+		go sc.runHandler(rw, req, handler, isHeader)
+		return
+	}
+	sc.unstartedHandlers = append(sc.unstartedHandlers, http2unstartedHandler{
+		streamID: streamID,
+		rw:       rw,
+		req:      req,
+		handler:  handler,
+		isHeader: isHeader,
+	})
+	return
+}
+
+func (sc *http2serverConn) handlerDone() {
+	sc.serveG.check()
+	sc.curHandlers--
+	i := 0
+	maxHandlers := sc.advMaxStreams * http2concurrentHandlerFactor
+	for ; i < len(sc.unstartedHandlers); i++ {
+		u := sc.unstartedHandlers[i]
+		if sc.streams[u.streamID] == nil {
+			// This stream was reset before its goroutine had a chance to start.
+			if http2enableConcurrentHeaderHandlerLimit && u.isHeader {
+				sc.headerHandlerSem <- struct{}{}
+			}
+			continue
+		}
+		if sc.curHandlers >= maxHandlers {
+			break
+		}
+		sc.curHandlers++
+		go sc.runHandler(u.rw, u.req, u.handler, u.isHeader)
+	}
+	sc.unstartedHandlers = sc.unstartedHandlers[i:]
 }
 
 // Run on its own goroutine.
-func (sc *http2serverConn) runHandler(rw *http2responseWriter, req *Request, handler func(ResponseWriter, *Request)) {
+func (sc *http2serverConn) runHandler(rw *http2responseWriter, req *Request, handler func(ResponseWriter, *Request), isHeader bool) {
+	if rw.rws == nil {
+		rw.prep()
+	}
+
 	didPanic := true
 	defer func() {
 		rw.rws.stream.cancelCtx()
 		if req.MultipartForm != nil {
 			req.MultipartForm.RemoveAll()
 		}
+		if http2enableConcurrentHeaderHandlerLimit && isHeader {
+			sc.headerHandlerSem <- struct{}{}
+		}
+		sc.sendServeMsg(http2handlerDoneMsg)
 		if didPanic {
 			e := recover()
 			sc.writeFrameFromHandler(http2FrameWriteRequest{
@@ -6046,7 +6385,10 @@ func (sc *http2serverConn) runHandler(rw *http2responseWriter, req *Request, han
 		}
 		rw.handlerDone()
 	}()
-	handler(rw, req)
+	// skip handler for canceled context
+	if req.Context().Err() == nil {
+		handler(rw, req)
+	}
 	didPanic = false
 }
 
@@ -6222,7 +6564,8 @@ func (b *http2requestBody) Read(p []byte) (n int, err error) {
 // simply crash (caller's mistake), but the much larger responseWriterState
 // and buffers are reused between multiple requests.
 type http2responseWriter struct {
-	rws *http2responseWriterState
+	prep func() // Assigns and prepares rws. (Lazy init.)
+	rws  *http2responseWriterState
 }
 
 // Optional http.ResponseWriter interfaces implemented.
@@ -6670,6 +7013,10 @@ func (w *http2responseWriter) write(lenData int, dataB []byte, dataS string) (n
 	if rws == nil {
 		panic("Write called after Handler finished")
 	}
+	if rws.stream.ctx.Err() != nil {
+		// skip write for canceled context
+		return 0, http2errStreamClosed
+	}
 	if !rws.wroteHeader {
 		w.WriteHeader(200)
 	}
@@ -6886,7 +7233,7 @@ func (sc *http2serverConn) startPush(msg *http2startPushRequest) {
 			panic(fmt.Sprintf("newWriterAndRequestNoBody(%+v): %v", msg.url, err))
 		}
 
-		go sc.runHandler(rw, req, sc.handler.ServeHTTP)
+		go sc.runHandler(rw, req, sc.handler.ServeHTTP, false)
 		return promisedID, nil
 	}
 
-- 
2.42.0.windows.2

