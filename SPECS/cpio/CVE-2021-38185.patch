Patch based on:
https://git.savannah.gnu.org/cgit/cpio.git/patch/?id=dd96882877721703e19272fe25034560b794061b

diff -urN a/src/copyin.c b/src/copyin.c
--- a/src/copyin.c	2022-04-20 08:48:57.765416169 +0000
+++ b/src/copyin.c	2022-04-20 09:17:48.970444221 +0000
@@ -1,6 +1,6 @@
 /* copyin.c - extract or list a cpio archive
-   Copyright (C) 1990-1992, 2001-2007, 2009-2010, 2014-2015, 2017 Free
-   Software Foundation, Inc.
+   Copyright (C) 1990-1992, 2001-2007, 2009-2010, 2014-2015, 2017,
+   2020-2021 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -55,11 +55,12 @@
   char *str_res;		/* Result for string function.  */
   static dynamic_string new_name;	/* New file name for rename option.  */
   static int initialized_new_name = false;
+
   if (!initialized_new_name)
-  {
-    ds_init (&new_name, 128);
-    initialized_new_name = true;
-  }
+    {
+      ds_init (&new_name);
+      initialized_new_name = true;
+    }
 
   if (rename_flag)
     {
@@ -758,8 +759,9 @@
 
   if ((file_hdr->c_mode & CP_IFMT) == CP_IFCHR
       || (file_hdr->c_mode & CP_IFMT) == CP_IFBLK)
-    printf ("%3lu, %3lu ", file_hdr->c_rdev_maj,
-	    file_hdr->c_rdev_min);
+    printf ("%3lu, %3lu ",
+	    (unsigned long) file_hdr->c_rdev_maj,
+	    (unsigned long) file_hdr->c_rdev_min);
   else
     printf ("%8"PRIuMAX" ", (uintmax_t) file_hdr->c_filesize);
 
@@ -779,37 +781,36 @@
    already in `save_patterns' (from the command line) are preserved.  */
 
 static void
-read_pattern_file ()
+read_pattern_file (void)
 {
-  int max_new_patterns;
-  char **new_save_patterns;
-  int new_num_patterns;
+  char **new_save_patterns = NULL;
+  size_t max_new_patterns;
+  size_t new_num_patterns;
   int i;
-  dynamic_string pattern_name;
+  dynamic_string pattern_name = DYNAMIC_STRING_INITIALIZER;
   FILE *pattern_fp;
 
   if (num_patterns < 0)
     num_patterns = 0;
-  max_new_patterns = 1 + num_patterns;
-  new_save_patterns = (char **) xmalloc (max_new_patterns * sizeof (char *));
   new_num_patterns = num_patterns;
-  ds_init (&pattern_name, 128);
+  max_new_patterns = num_patterns;
+  new_save_patterns = xcalloc (max_new_patterns, sizeof (new_save_patterns[0]));
 
   pattern_fp = fopen (pattern_file_name, "r");
   if (pattern_fp == NULL)
     open_fatal (pattern_file_name);
   while (ds_fgetstr (pattern_fp, &pattern_name, '\n') != NULL)
     {
-      if (new_num_patterns >= max_new_patterns)
-	{
-	  max_new_patterns += 1;
-	  new_save_patterns = (char **)
-	    xrealloc ((char *) new_save_patterns,
-		      max_new_patterns * sizeof (char *));
-	}
+      if (new_num_patterns == max_new_patterns)
+	new_save_patterns = x2nrealloc (new_save_patterns,
+					&max_new_patterns,
+					sizeof (new_save_patterns[0]));
       new_save_patterns[new_num_patterns] = xstrdup (pattern_name.ds_string);
       ++new_num_patterns;
     }
+
+  ds_free (&pattern_name);
+  
   if (ferror (pattern_fp) || fclose (pattern_fp) == EOF)
     close_error (pattern_file_name);
 
@@ -998,8 +999,21 @@
 static void
 read_name_from_file (struct cpio_file_stat *file_hdr, int fd, uintmax_t len)
 {
-  cpio_realloc_c_name (file_hdr, len);
-  tape_buffered_read (file_hdr->c_name, fd, len);
+  if (len == 0)
+    {
+      error (0, 0, _("malformed header: file name of zero length"));
+    }
+  else
+    {
+      cpio_realloc_c_name (file_hdr, len);
+      tape_buffered_read (file_hdr->c_name, fd, len);
+      if (file_hdr->c_name[len-1] != 0)
+	{
+	  error (0, 0, _("malformed header: file name is not nul-terminated"));
+	  /* Skip this file */
+	  len = 0;
+	}
+    }
   file_hdr->c_namesize = len;
 }
 
@@ -1196,9 +1210,8 @@
    in the file system.  */
 
 void
-process_copy_in ()
+process_copy_in (void)
 {
-  char done = false;		/* True if trailer reached.  */
   FILE *tty_in = NULL;		/* Interactive file for rename option.  */
   FILE *tty_out = NULL;		/* Interactive file for rename option.  */
   FILE *rename_in = NULL;	/* Batch file for rename option.  */
@@ -1270,7 +1283,7 @@
   change_dir ();
   
   /* While there is more input in the collection, process the input.  */
-  while (!done)
+  while (1)
     {
       swapping_halfwords = swapping_bytes = false;
 
@@ -1304,10 +1317,7 @@
 	{
 	  /* Is this the header for the TRAILER file?  */
 	  if (strcmp (CPIO_TRAILER_NAME, file_hdr.c_name) == 0)
-	    {
-	      done = true;
-	      break;
-	    }
+	    break;
 
 	  cpio_safer_name_suffix (file_hdr.c_name, false, !no_abs_paths_flag,
 				  false);
@@ -1437,4 +1447,3 @@
 	       (unsigned long) blocks);
     }
 }
-
diff -urN a/src/copyout.c b/src/copyout.c
--- a/src/copyout.c	2022-04-20 08:48:57.765416169 +0000
+++ b/src/copyout.c	2022-04-20 09:19:32.002290490 +0000
@@ -594,9 +594,10 @@
    The format of the header depends on the compatibility (-c) flag.  */
 
 void
-process_copy_out ()
+process_copy_out (void)
 {
-  dynamic_string input_name;	/* Name of file read from stdin.  */
+  dynamic_string input_name = DYNAMIC_STRING_INITIALIZER;
+                                /* Name of file read from stdin.  */
   struct stat file_stat;	/* Stat record for file.  */
   struct cpio_file_stat file_hdr = CPIO_FILE_STAT_INITIALIZER;
                                 /* Output header information.  */
@@ -605,7 +606,6 @@
   char *orig_file_name = NULL;
 
   /* Initialize the copy out.  */
-  ds_init (&input_name, 128);
   file_hdr.c_magic = 070707;
 
   /* Check whether the output file might be a tape.  */
@@ -657,14 +657,9 @@
 	    {
 	      if (file_hdr.c_mode & CP_IFDIR)
 		{
-		  int len = strlen (input_name.ds_string);
 		  /* Make sure the name ends with a slash */
-		  if (input_name.ds_string[len-1] != '/')
-		    {
-		      ds_resize (&input_name, len + 2);
-		      input_name.ds_string[len] = '/';
-		      input_name.ds_string[len+1] = 0;
-		    }
+		  if (!ds_endswith (&input_name, '/'))
+		    ds_append (&input_name, '/');
 		}
 	    }
 	  
@@ -875,6 +870,7 @@
 			 (unsigned long) blocks), (unsigned long) blocks);
     }
   cpio_file_stat_free (&file_hdr);
+  ds_free (&input_name);
 }
 
 
diff -urN a/src/copypass.c b/src/copypass.c
--- a/src/copypass.c	2022-04-20 08:48:57.765416169 +0000
+++ b/src/copypass.c	2022-04-20 09:07:16.394766063 +0000
@@ -48,10 +48,12 @@
    If `link_flag', link instead of copying.  */
 
 void
-process_copy_pass ()
+process_copy_pass (void)
 {
-  dynamic_string input_name;	/* Name of file from stdin.  */
-  dynamic_string output_name;	/* Name of new file.  */
+  dynamic_string input_name = DYNAMIC_STRING_INITIALIZER;
+                                /* Name of file from stdin.  */
+  dynamic_string output_name = DYNAMIC_STRING_INITIALIZER;
+                                /* Name of new file.  */
   size_t dirname_len;		/* Length of `directory_name'.  */
   int res;			/* Result of functions.  */
   char *slash;			/* For moving past slashes in input name.  */
@@ -65,25 +67,18 @@
 				   created files  */
 
   /* Initialize the copy pass.  */
-  ds_init (&input_name, 128);
   
   dirname_len = strlen (directory_name);
   if (change_directory_option && !ISSLASH (directory_name[0]))
     {
       char *pwd = xgetcwd ();
 
-      dirname_len += strlen (pwd) + 1;
-      ds_init (&output_name, dirname_len + 2);
-      strcpy (output_name.ds_string, pwd);
-      strcat (output_name.ds_string, "/");
-      strcat (output_name.ds_string, directory_name);
+      ds_concat (&output_name, pwd);
+      ds_append (&output_name, '/');
     }
-  else
-    {
-      ds_init (&output_name, dirname_len + 2);
-      strcpy (output_name.ds_string, directory_name);
-    }
-  output_name.ds_string[dirname_len] = '/';
+  ds_concat (&output_name, directory_name);
+  ds_append (&output_name, '/');
+  dirname_len = ds_len (&output_name);
   output_is_seekable = true;
 
   change_dir ();
@@ -116,8 +111,8 @@
       /* Make the name of the new file.  */
       for (slash = input_name.ds_string; *slash == '/'; ++slash)
 	;
-      ds_resize (&output_name, dirname_len + strlen (slash) + 2);
-      strcpy (output_name.ds_string + dirname_len + 1, slash);
+      ds_reset (&output_name, dirname_len);
+      ds_concat (&output_name, slash);
 
       existing_dir = false;
       if (lstat (output_name.ds_string, &out_file_stat) == 0)
@@ -333,6 +328,8 @@
 			 (unsigned long) blocks),
 	       (unsigned long) blocks);
     }
+  ds_free (&input_name);
+  ds_free (&output_name);
 }
 
 /* Try and create a hard link from FILE_NAME to another file 
diff -urN a/src/dstring.c b/src/dstring.c
--- a/src/dstring.c	2022-04-20 08:48:57.769416154 +0000
+++ b/src/dstring.c	2022-04-20 09:08:14.558804808 +0000
@@ -1,6 +1,6 @@
 /* dstring.c - The dynamic string handling routines used by cpio.
-   Copyright (C) 1990-1992, 2004, 2007, 2010, 2014-2015, 2017 Free
-   Software Foundation, Inc.
+   Copyright (C) 1990-1992, 2004, 2007, 2010, 2014-2015, 2017, 2020-2021
+   Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -20,8 +20,8 @@
 #if defined(HAVE_CONFIG_H)
 # include <config.h>
 #endif
-
 #include <stdio.h>
+#include <stdlib.h>
 #if defined(HAVE_STRING_H) || defined(STDC_HEADERS)
 #include <string.h>
 #else
@@ -33,24 +33,41 @@
 /* Initialiaze dynamic string STRING with space for SIZE characters.  */
 
 void
-ds_init (dynamic_string *string, int size)
+ds_init (dynamic_string *string)
+{
+  memset (string, 0, sizeof *string);
+}
+
+/* Free the dynamic string storage. */
+
+void
+ds_free (dynamic_string *string)
 {
-  string->ds_length = size;
-  string->ds_string = (char *) xmalloc (size);
+  free (string->ds_string);
 }
 
-/* Expand dynamic string STRING, if necessary, to hold SIZE characters.  */
+/* Expand dynamic string STRING, if necessary.  */
 
 void
-ds_resize (dynamic_string *string, int size)
+ds_resize (dynamic_string *string)
 {
-  if (size > string->ds_length)
+  if (string->ds_idx == string->ds_size)
     {
-      string->ds_length = size;
-      string->ds_string = (char *) xrealloc ((char *) string->ds_string, size);
+      string->ds_string = x2nrealloc (string->ds_string, &string->ds_size,
+				      1);
     }
 }
 
+/* Reset the index of the dynamic string S to LEN. */
+
+void
+ds_reset (dynamic_string *s, size_t len)
+{
+  while (len > s->ds_size)
+    ds_resize (s);
+  s->ds_idx = len;
+}
+
 /* Dynamic string S gets a string terminated by the EOS character
    (which is removed) from file F.  S will increase
    in size during the function if the string from F is longer than
@@ -61,34 +78,50 @@
 char *
 ds_fgetstr (FILE *f, dynamic_string *s, char eos)
 {
-  int insize;			/* Amount needed for line.  */
-  int strsize;			/* Amount allocated for S.  */
   int next_ch;
 
   /* Initialize.  */
-  insize = 0;
-  strsize = s->ds_length;
+  s->ds_idx = 0;
 
   /* Read the input string.  */
-  next_ch = getc (f);
-  while (next_ch != eos && next_ch != EOF)
+  while ((next_ch = getc (f)) != eos && next_ch != EOF)
     {
-      if (insize >= strsize - 1)
-	{
-	  ds_resize (s, strsize * 2 + 2);
-	  strsize = s->ds_length;
-	}
-      s->ds_string[insize++] = next_ch;
-      next_ch = getc (f);
+      ds_resize (s);
+      s->ds_string[s->ds_idx++] = next_ch;
     }
-  s->ds_string[insize++] = '\0';
+  ds_resize (s);
+  s->ds_string[s->ds_idx] = '\0';
 
-  if (insize == 1 && next_ch == EOF)
+  if (s->ds_idx == 0 && next_ch == EOF)
     return NULL;
   else
     return s->ds_string;
 }
 
+void
+ds_append (dynamic_string *s, int c)
+{
+  ds_resize (s);
+  s->ds_string[s->ds_idx] = c;
+  if (c)
+    {
+      s->ds_idx++;
+      ds_resize (s);
+      s->ds_string[s->ds_idx] = 0;
+    }      
+}
+
+void
+ds_concat (dynamic_string *s, char const *str)
+{
+  size_t len = strlen (str);
+  while (len + 1 > s->ds_size)
+    ds_resize (s);
+  memcpy (s->ds_string + s->ds_idx, str, len);
+  s->ds_idx += len;
+  s->ds_string[s->ds_idx] = 0;
+}
+
 char *
 ds_fgets (FILE *f, dynamic_string *s)
 {
@@ -100,3 +133,10 @@
 {
   return ds_fgetstr (f, s, '\0');
 }
+
+/* Return true if the dynamic string S ends with character C. */
+int
+ds_endswith (dynamic_string *s, int c)
+{
+  return (s->ds_idx > 0 && s->ds_string[s->ds_idx - 1] == c);
+}
\ No newline at end of file
diff -urN a/src/dstring.h b/src/dstring.h
--- a/src/dstring.h	2022-04-20 08:48:57.769416154 +0000
+++ b/src/dstring.h	2022-04-20 09:08:54.914820579 +0000
@@ -1,6 +1,6 @@
 /* dstring.h - Dynamic string handling include file.  Requires strings.h.
-   Copyright (C) 1990-1992, 2004, 2007, 2010, 2014-2015, 2017 Free
-   Software Foundation, Inc.
+   Copyright (C) 1990-1992, 2004, 2007, 2010, 2014-2015, 2017, 2020-2021
+   Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -17,10 +17,6 @@
    Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
    Boston, MA 02110-1301 USA.  */
 
-#ifndef NULL
-#define NULL 0
-#endif
-
 /* A dynamic string consists of record that records the size of an
    allocated string and the pointer to that string.  The actual string
    is a normal zero byte terminated string that can be used with the
@@ -30,22 +26,24 @@
 
 typedef struct
 {
-  int ds_length;		/* Actual amount of storage allocated.  */
-  char *ds_string;		/* String.  */
+  size_t ds_size;   /* Actual amount of storage allocated.  */
+  size_t ds_idx;    /* Index of the next free byte in the string. */
+  char *ds_string;  /* String storage. */
 } dynamic_string;
 
+#define DYNAMIC_STRING_INITIALIZER { 0, 0, NULL }
 
-/* Macros that look similar to the original string functions.
-   WARNING:  These macros work only on pointers to dynamic string records.
-   If used with a real record, an "&" must be used to get the pointer.  */
-#define ds_strlen(s)		strlen ((s)->ds_string)
-#define ds_strcmp(s1, s2)	strcmp ((s1)->ds_string, (s2)->ds_string)
-#define ds_strncmp(s1, s2, n)	strncmp ((s1)->ds_string, (s2)->ds_string, n)
-#define ds_index(s, c)		index ((s)->ds_string, c)
-#define ds_rindex(s, c)		rindex ((s)->ds_string, c)
+void ds_init (dynamic_string *string);
+void ds_free (dynamic_string *string);
+void ds_reset (dynamic_string *s, size_t len);
 
-void ds_init (dynamic_string *string, int size);
-void ds_resize (dynamic_string *string, int size);
+/* All functions below guarantee that s->ds_string[s->ds_idx] == '\0' */
 char *ds_fgetname (FILE *f, dynamic_string *s);
 char *ds_fgets (FILE *f, dynamic_string *s);
 char *ds_fgetstr (FILE *f, dynamic_string *s, char eos);
+void ds_append (dynamic_string *s, int c);
+void ds_concat (dynamic_string *s, char const *str);
+
+#define ds_len(s) ((s)->ds_idx)
+
+int ds_endswith (dynamic_string *s, int c);
diff -urN a/src/util.c b/src/util.c
--- a/src/util.c	2022-04-20 08:48:57.773416140 +0000
+++ b/src/util.c	2022-04-20 09:09:23.046826620 +0000
@@ -1,6 +1,6 @@
 /* util.c - Several utility routines for cpio.
    Copyright (C) 1990-1992, 2001, 2004, 2006-2007, 2010-2011, 2014-2015,
-   2017 Free Software Foundation, Inc.
+   2017, 2020-2021 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -846,11 +846,9 @@
   FILE *tty_out;		/* File for interacting with user.  */
   int old_tape_des;
   char *next_archive_name;
-  dynamic_string new_name;
+  dynamic_string new_name = DYNAMIC_STRING_INITIALIZER;
   char *str_res;
 
-  ds_init (&new_name, 128);
-
   /* Open files for interactive communication.  */
   tty_in = fopen (TTY_NAME, "r");
   if (tty_in == NULL)
@@ -925,7 +923,7 @@
     error (PAXEXIT_FAILURE, 0, _("internal error: tape descriptor changed from %d to %d"),
 	   old_tape_des, tape_des);
 
-  free (new_name.ds_string);
+  ds_free (&new_name);
   fclose (tty_in);
   fclose (tty_out);
 }
@@ -1140,8 +1138,16 @@
   hdr->c_nlink = st->st_nlink;
   hdr->c_uid = CPIO_UID (st->st_uid);
   hdr->c_gid = CPIO_GID (st->st_gid);
-  hdr->c_rdev_maj = major (st->st_rdev);
-  hdr->c_rdev_min = minor (st->st_rdev);
+  if (S_ISBLK (st->st_mode) || S_ISCHR (st->st_mode))
+    {
+      hdr->c_rdev_maj = major (st->st_rdev);
+      hdr->c_rdev_min = minor (st->st_rdev);
+    }
+  else
+    {
+      hdr->c_rdev_maj = 0;
+      hdr->c_rdev_min = 0;
+    }
   hdr->c_mtime = st->st_mtime;
   hdr->c_filesize = st->st_size;
   hdr->c_chksum = 0;
@@ -1542,4 +1548,4 @@
 {
   free (file_hdr->c_name);
   cpio_file_stat_init (file_hdr);
-}
+}
\ No newline at end of file
